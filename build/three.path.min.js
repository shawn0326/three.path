// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";class s{constructor(){this.pos=new e.Vector3,this.dir=new e.Vector3,this.right=new e.Vector3,this.up=new e.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const r=new e.Vector3,i=new e.Vector3,a=new e.Vector3,n=new e.Matrix4,o=new e.QuadraticBezierCurve3;class u extends e.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,s){this.setAttribute("position",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),s&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new e.Uint32BufferAttribute(3*t,1):new e.Uint16BufferAttribute(3*t,1))}_initByData(t,s={},r,i){const a=h(t,s,i);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(r||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(r||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(r||e.StaticDrawUsage)),i&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(r||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),r=h(t,e,s);r?(this._updateAttributes(r.position,r.normal,r.uv,s?r.uv2:null,r.indices),this.drawRange.count=r.count):this.drawRange.count=0}_resizeAttribute(t,s){let r=this.getAttribute(t);for(;r.array.length<s;){const s=r.array.length,i=new e.BufferAttribute(new Float32Array(2*s),r.itemSize,r.normalized);i.name=r.name,i.usage=r.usage,this.setAttribute(t,i),r=i}}_resizeIndex(t){let s=this.getIndex();for(;s.array.length<t;){const t=s.array.length,r=new e.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);r.name=s.name,r.usage=s.usage,this.setIndex(r),s=r}}_updateAttributes(t,e,s,r,i){this._resizeAttribute("position",t.length);const a=this.getAttribute("position");a.array.set(t,0),a.addUpdateRange?(a.clearUpdateRanges(),a.addUpdateRange(0,t.length)):a.updateRange.count=t.length,a.needsUpdate=!0,this._resizeAttribute("normal",e.length);const n=this.getAttribute("normal");n.array.set(e,0),n.addUpdateRange?(n.clearUpdateRanges(),n.addUpdateRange(0,e.length)):n.updateRange.count=e.length,n.needsUpdate=!0,this._resizeAttribute("uv",s.length);const o=this.getAttribute("uv");if(o.array.set(s,0),o.addUpdateRange?(o.clearUpdateRanges(),o.addUpdateRange(0,s.length)):o.updateRange.count=s.length,o.needsUpdate=!0,r){this._resizeAttribute("uv2",r.length);const t=this.getAttribute("uv2");t.array.set(r,0),t.addUpdateRange?(t.clearUpdateRanges(),t.addUpdateRange(0,r.length)):t.updateRange.count=r.length,t.needsUpdate=!0}this._resizeIndex(i.length);const u=this.getIndex();u.set(i,0),u.addUpdateRange?(u.clearUpdateRanges(),u.addUpdateRange(0,i.length)):u.updateRange.count=i.length,u.needsUpdate=!0}}function h(t,r,i=!1){const a=r.width||.1,n=void 0!==r.progress?r.progress:1,o=void 0===r.arrow||r.arrow,u=void 0!==r.side?r.side:"both",h=a/2,c="both"!==u?a/2:a,d=t.distance(),p=n*d;if(0==d)return null;const l=h/c,y=h/d;let g=0;const f=[],w=[],b=[],A=[],m=[];let x=0;const z=new e.Vector3,U=new e.Vector3,V=new e.Vector3,S=new e.Vector3,v=new e.Vector3,B=new e.Vector3;function _(t){const e=0===f.length,s=t.sharp&&!e,r=t.dist/c,a=t.dist/d,n=t.dir,o=t.up,p=t.right;if("left"!==u?z.copy(p).multiplyScalar(h*t.widthScale):z.set(0,0,0),"right"!==u?U.copy(p).multiplyScalar(-h*t.widthScale):U.set(0,0,0),z.add(t.pos),U.add(t.pos),s){V.fromArray(f,f.length-6).sub(U),S.fromArray(f,f.length-3).sub(z);const t=V.length()-S.length();let e,s;t>0?(e=V,s=U):(e=S,s=z),v.copy(e).setLength(Math.abs(t)).add(s);const u=B.copy(s).sub(v).normalize().dot(n)*B.copy(s).sub(v).length()*2;B.copy(n).setLength(u).add(v),t>0?(f.push(v.x,v.y,v.z,z.x,z.y,z.z,U.x,U.y,U.z,z.x,z.y,z.z,B.x,B.y,B.z,z.x,z.y,z.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-4,x-6,x-5,x-2,x-4,x-1),g+=12):(f.push(U.x,U.y,U.z,v.x,v.y,v.z,U.x,U.y,U.z,z.x,z.y,z.z,U.x,U.y,U.z,B.x,B.y,B.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-6,x-5,x-3,x-2,x-3,x-1),g+=12),w.push(o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z),b.push(r-l,0,r-l,1,r,0,r,1,r+l,0,r+l,1),i&&A.push(a-y,0,a-y,1,a,0,a,1,a+y,0,a+y,1)}else f.push(U.x,U.y,U.z,z.x,z.y,z.z),w.push(o.x,o.y,o.z,o.x,o.y,o.z),b.push(r,0,r,1),i&&A.push(a,0,a,1),x+=2,e||(m.push(x-2,x-4,x-3,x-2,x-3,x-1),g+=6)}const R=new e.Vector3;let M;if(p>0)for(let e=0;e<t.count;e++){const r=t.array[e];if(r.dist>p){const i=t.array[e-1];M=new s;const a=(p-i.dist)/(r.dist-i.dist);M.lerpPathPoints(i,r,a),_(M);break}_(r)}else M=t.array[0];return o&&(M=M||t.array[t.count-1],function(t){const e=t.dir,s=t.up,r=t.right,n=t.dist/c,o=t.dist/d;"left"!==u?z.copy(r).multiplyScalar(2*h):z.set(0,0,0),"right"!==u?U.copy(r).multiplyScalar(2*-h):U.set(0,0,0),R.copy(e).setLength(3*h),z.add(t.pos),U.add(t.pos),R.add(t.pos),f.push(U.x,U.y,U.z,z.x,z.y,z.z,R.x,R.y,R.z),w.push(s.x,s.y,s.z,s.x,s.y,s.z,s.x,s.y,s.z),b.push(n,"both"!==u?"right"!==u?-2:0:-.5,n,"both"!==u?"left"!==u?2:0:1.5,n+1.5,"both"!==u?0:.5),i&&A.push(o,"both"!==u?"right"!==u?-2:0:-.5,o,"both"!==u?"left"!==u?2:0:1.5,o+1.5*a/d,"both"!==u?0:.5),x+=3,m.push(x-1,x-3,x-2),g+=3}(M)),{position:f,normal:w,uv:b,uv2:A,indices:m,count:g}}function c(t,r,i=!1){const a=r.radius||.1,n=void 0!==r.progress?r.progress:1,o=Math.max(2,r.radialSegments||8),u=r.startRad||0,h=r.generateFlatStartCap||!1,c=r.generateFlatEndCap||!1,d=2*a*Math.PI,p=t.distance(),l=n*p;if(0==l)return null;let y=0;const g=[],f=[],w=[],b=[],A=[];let m=0;const x=new e.Vector3;function z(t,e,s){const r=0===g.length,a=t.dist/d,n=t.dist/p;for(let r=0;r<=s;r++){let o=r;o==s&&(o=0),x.copy(t.up).applyAxisAngle(t.dir,u+2*Math.PI*o/s).normalize(),g.push(t.pos.x+x.x*e*t.widthScale,t.pos.y+x.y*e*t.widthScale,t.pos.z+x.z*e*t.widthScale),f.push(x.x,x.y,x.z),w.push(a,r/s),i&&b.push(n,r/s),m++}if(!r){const t=m-2*(s+1),e=m-(s+1);for(let r=0;r<s;r++)A.push(e+r,t+r,t+r+1,e+r,t+r+1,e+r+1),y+=6}}if(l>0){const e=t.array[0];let r=t.array[t.count-1];for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>l){const n=t.array[e-1],u=new s,h=(l-n.dist)/(i.dist-n.dist);u.lerpPathPoints(n,i,h),r=u,z(u,a,o);break}z(i,a,o)}if(o>=3&&c){x.copy(r.dir),x.normalize();for(let t=m-o,e=m;t<e;t++)g.push(g[3*t],g[3*t+1],g[3*t+2]),w.push(w[2*t],w[2*t+1]),i&&b.push(b[2*t],b[2*t+1]),f.push(x.x,x.y,x.z),m++;const t=m-o;for(let e=0;e<o-2;e++)A.push(t,t+e+1,t+e+2),y+=3}if(o>=3&&h){x.copy(e.dir),x.normalize();for(let t=0;t<o;t++)g.push(g[3*t],g[3*t+1],g[3*t+2]),w.push(w[2*t],w[2*t+1]),i&&b.push(b[2*t],b[2*t+1]),f.push(-x.x,-x.y,-x.z),m++;const t=m-o;for(let e=0;e<o-2;e++)A.push(t,t+e+2,t+e+1),y+=3}}return{position:g,normal:f,uv:w,uv2:b,indices:A,count:y}}t.PathGeometry=u,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,s=.1,r=10,i=null,a=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);a&&!t[0].equals(t[t.length-1])&&t.push((new e.Vector3).copy(t[0]));for(let e=0,n=t.length;e<n;e++)if(0===e)this._start(t[e],t[e+1],i);else if(e===n-1)if(a){this._corner(t[e],t[1],s,r,i);const a=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=a}else this._end(t[e]);else this._corner(t[e],t[e+1],s,r,i)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new s),this.array[t]}_start(t,e,s){this.count=0;const r=this._getByIndex(this.count);if(r.pos.copy(t),r.dir.subVectors(e,t),s)r.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(r.dir.x),s=Math.abs(r.dir.y),i=Math.abs(r.dir.z);e<t&&(t=e,r.up.set(1,0,0)),s<t&&(t=s,r.up.set(0,1,0)),i<t&&r.up.set(0,0,1)}r.right.crossVectors(r.dir,r.up).normalize(),r.up.crossVectors(r.right,r.dir).normalize(),r.dist=0,r.widthScale=1,r.sharp=!1,r.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],s=this._getByIndex(this.count);s.pos.copy(t),s.dir.subVectors(t,e.pos);const i=s.dir.length();s.dir.normalize(),s.up.copy(e.up);const a=r.crossVectors(e.dir,s.dir);if(a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(s.dir),-1),1));s.up.applyMatrix4(n.makeRotationAxis(a,t))}s.right.crossVectors(s.dir,s.up).normalize(),s.dist=e.dist+i,s.widthScale=1,s.sharp=!1,this.count++}_corner(t,e,s,a,n){if(s>0&&a>0){const u=function(t,e,s,a,n,o){const u=r.subVectors(e,t),h=i.subVectors(s,e),c=u.length(),d=h.length();u.normalize(),h.normalize();const p=Math.min(.999999*(n?c/2:c),a);o.v0.copy(e).sub(u.multiplyScalar(p)),o.v1.copy(e);const l=Math.min(d/2*.999999,a);return o.v2.copy(e).add(h.multiplyScalar(l)),o}(this.array[this.count-1].pos,t,e,s,this.count-1==0,o),h=u.getPoints(a);for(let t=0;t<a;t++)this._sharpCorner(h[t],h[t+1],n,0===t?1:0);h[a].equals(e)||this._sharpCorner(h[a],e,n,2)}else this._sharpCorner(t,e,n,0,!0)}_sharpCorner(t,e,s,o=0,u=!1){const h=this.array[this.count-1],c=this._getByIndex(this.count),d=r.subVectors(t,h.pos),p=i.subVectors(e,t),l=d.length();if(d.normalize(),p.normalize(),c.pos.copy(t),1===o?c.dir.copy(d):2===o?c.dir.copy(p):(c.dir.addVectors(d,p),c.dir.normalize()),s)1===c.dir.dot(s)?c.right.crossVectors(p,s).normalize():c.right.crossVectors(c.dir,s).normalize(),c.up.crossVectors(c.right,c.dir).normalize();else{c.up.copy(h.up);const t=a.crossVectors(h.dir,c.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(h.dir.dot(c.dir),-1),1));c.up.applyMatrix4(n.makeRotationAxis(t,e))}c.right.crossVectors(c.dir,c.up).normalize()}c.dist=h.dist+l;const y=d.dot(p);c.widthScale=Math.min(1/Math.sqrt((1+y)/2),1.415)||1,c.sharp=Math.abs(y-1)>.05&&u,this.count++}},t.PathTubeGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},r,i){const a=c(t,s,i);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(r||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(r||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(r||e.StaticDrawUsage)),i&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(r||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,i)}update(t,e={}){const s=!!this.getAttribute("uv2"),r=c(t,e,s);r?(this._updateAttributes(r.position,r.normal,r.uv,s?r.uv2:null,r.indices),this.drawRange.count=r.count):this.drawRange.count=0}}}));
